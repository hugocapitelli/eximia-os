    # ===== M√©todos para V√≠deos =====
    
    def _is_video_url(self, url: str) -> bool:
        """Detecta se URL √© de v√≠deo"""
        video_platforms = ['youtube.com', 'youtu.be', 'vimeo.com', 'dailymotion.com', 'twitch.tv']
        return any(platform in url.lower() for platform in video_platforms)
    
    def _handle_video_add(self, url: str, auto_approve: bool = False) -> dict:
        """
        Workflow espec√≠fico para adicionar v√≠deos (com transcri√ß√£o)
        
        Args:
            url: URL do v√≠deo
            auto_approve: Se True, pula review
        
        Returns:
            Dict com resultado do workflow
        """
        print(f"üé¨ V√≠deo detectado!")
        print(f"üéµ Extraindo √°udio e transcrevendo...")
        
        # Usar m√©todo padr√£o: gemini (mais acess√≠vel para o usu√°rio)
        method = os.getenv('TRANSCRIPTION_DEFAULT_METHOD', 'gemini')
        
       # Transcrever v√≠deo
        transcribe_result = self.transcriber.transcribe_video(url, method=method)
        
        if transcribe_result['status'] != 'success':
            print(f"‚ùå Erro na transcri√ß√£o: {transcribe_result.get('message')}")
            return transcribe_result
        
        transcript = transcribe_result['transcript']
        video_metadata = transcribe_result['metadata']
        
        print(f"‚úÖ Transcri√ß√£o completa!")
        print(f"   T√≠tulo: {video_metadata.get('title', 'Unknown Video')}")
        print(f"   Dura√ß√£o: {video_metadata.get('duration', 0)}s")
        print(f"   Confian√ßa: {video_metadata.get('confidence', 0):.2f}")
        
        # Criar arquivo markdown com a transcri√ß√£o
        content_id = self.scraper._slugify(video_metadata.get('title', 'video'))
        
        # Formatar conte√∫do
        markdown_content = self._format_video_transcript(transcript, video_metadata, url)
        
        # Salvar em INBOX local
        inbox_dir = self.codex_path / "eximia_data" / "00_INBOX"
        inbox_dir.mkdir(parents=True, exist_ok=True)
        local_file_path = inbox_dir / f"{content_id}.md"
        local_file_path.write_text(markdown_content, encoding='utf-8')
        
        # Categorizar
        print(f"\nü§ñ Categorizando com IA...")
        cat_result = self.categorizer.analyze_content(
            str(local_file_path),
            metadata={'title': video_metadata.get('title', 'Unknown Video')}
        )
        
        if cat_result['status'] != 'success':
            print(f"‚ùå Erro ao categorizar: {cat_result.get('error')}")
            return cat_result
        
        categorization = cat_result['categorization']
        
        # For√ßar tipo como 'video' ou 'video_transcript'
        categorization['type'] = 'video'
        
        print(f"‚úÖ Categoriza√ß√£o completa:")
        print(f"   Tipo: {categorization['type']}")
        print(f"  Tags: {', '.join(categorization['tags'][:5])}")
        print(f"   Confian√ßa: {categorization['confidence']:.2f}")
        
        # Review ou Auto-approve
        if not auto_approve:
            print(f"\nüìã Preview:")
            print(f"   ID: {content_id}")
            print(f"   T√≠tulo: {video_metadata.get('title')}")
            print(f"   Transcri√ß√£o: {transcript[:200]}...")
            
            response = input("\n‚úÖ Aprovar e adicionar √† biblioteca? (s/N): ")
            if response.lower() != 's':
                print("‚ùå Opera√ß√£o cancelada")
                return {"status": "cancelled"}
        
        # Upload para Cloud Storage
        print(f"\n‚òÅÔ∏è Sincronizando com a Nuvem...")
        remote_path = f"eximia_data/00_INBOX/{local_file_path.name}"
        
        if storage.upload_file(local_file_path, remote_path):
            print("   ‚úÖ Upload conclu√≠do")
        else:
            print("   ‚ö†Ô∏è  Falha no upload (usando c√≥pia local)")
        
        # Salvar no database
        print(f"üíæ Salvando no database...")
        
        try:
            self.db.add_content(
                content_id=content_id,
                title=video_metadata.get('title', 'Unknown Video'),
                content_type='video',
                source_url=url,
                author=video_metadata.get('author'),
                file_path=str(remote_path),
                tags=categorization['tags'],
                notes=categorization['summary']
            )
            
            # Auto-approve
            if auto_approve:
                approve_res = self._approve_content({
                    'id': content_id, 
                    'type': 'video', 
                    'file_path': str(remote_path)
                })
                content_id = approve_res.get('new_id', content_id)
            
            print(f"‚úÖ V√≠deo adicionado com sucesso!")
            print(f"   ID: {content_id}")
            print(f"   Status: {'library' if auto_approve else 'inbox'}")
            
            return {
                "status": "success",
                "content_id": content_id,
                "categorization": categorization
            }
        
        except Exception as e:
            print(f"‚ùå Erro ao salvar: {e}")
            return {"status": "error", "error": str(e)}
    
    def _format_video_transcript(self, transcript: str, metadata: dict, url: str) -> str:
        """Formata transcri√ß√£o de v√≠deo em Markdown"""
        title = metadata.get('title', 'Unknown Video')
        author = metadata.get('author', 'N/A')
        duration = metadata.get('duration', 0)
        platform = metadata.get('platform', 'unknown')
        upload_date = metadata.get('upload_date', 'N/A')
        
        # Formatar dura√ß√£o
        if duration > 0:
            minutes = duration // 60
            seconds = duration % 60
            duration_str = f"{minutes}m{seconds}s"
        else:
            duration_str = "N/A"
        
        markdown = f"""# {title}

> **Fonte:** {url}  
> **Plataforma:** {platform}  
> **Autor/Canal:** {author}  
> **Dura√ß√£o:** {duration_str}  
> **Data de Publica√ß√£o:** {upload_date}

## Transcri√ß√£o

{transcript}

---

*Transcri√ß√£o gerada automaticamente usando {metadata.get('transcript_method', 'AI')}*
"""
        return markdown
    
    def cmd_transcribe(self, file_path: str, method: str = "gemini") -> dict:
        """
        Transcrever arquivo de v√≠deo/√°udio local
        
        Args:
            file_path: Caminho para arquivo de v√≠deo ou √°udio
            method: M√©todo de transcri√ß√£o (whisper, google, gemini)
        """
        if not Path(file_path).exists():
            print(f"‚ùå Arquivo n√£o encontrado: {file_path}")
            return {"status": "error", "message": "file_not_found"}
        
        print(f"üé¨ Transcrevendo arquivo local: {file_path}")
        
        result = self.transcriber.transcribe_video(file_path, method=method)
        
        if result['status'] == 'success':
            print(f"‚úÖ Transcri√ß√£o completa ({len(result['transcript'])} caracteres)")
            
            # Salvar automaticamente no Codex
            file_obj = Path(file_path)
            content_id = self.scraper._slugify(file_obj.stem)
            
           # Criar markdown
            markdown_content = self._format_video_transcript(
                result['transcript'],
                result['metadata'],
                f"file:///{file_path}"
            )
            
            # Salvar no INBOX
            inbox_dir = self.codex_path / "eximia_data" / "00_INBOX"
            inbox_dir.mkdir(parents=True, exist_ok=True)
            local_file = inbox_dir / f"{content_id}.md"
            local_file.write_text(markdown_content, encoding='utf-8')
            
            # Upload para cloud
            remote_path = f"eximia_data/00_INBOX/{local_file.name}"
            storage.upload_file(local_file, remote_path)
            
            # Adicionar ao database
            self.db.add_content(
                content_id=content_id,
                title=file_obj.stem,
                content_type='video',
                source_url=f"file:///{file_path}",
                file_path=remote_path,
                tags=['video', 'local', 'transcription'],
                notes=f"Arquivo local transcrito usando {method}"
            )
            
            print(f"üíæ Salvo no Codex como: {content_id}")
            print(f"üìÑ Use /codex-review para aprovar")
        
        return result
