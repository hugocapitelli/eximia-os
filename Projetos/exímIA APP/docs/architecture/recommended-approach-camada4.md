# Recommended Approach: Camada 4 Integration

**Generated:** 2026-01-28
**Generated By:** @architect (Aria)
**Feature:** Camada 4 â€” Execution Intelligence Operating System
**Source:** `EXIMIA_OS_CAMADA4_PROPOSTA_IMPLEMENTACAO.md`

---

## Feature Requirements

### Description
Integrate the **Camada 4 (Execution Intelligence Operating System)** into ExÃ­mIA APP. This adds a governance layer that transforms decisions into sustained human behavior through:

- Decision Cards with 5 mandatory questions
- Multi-agent vigilance system (6 agents)
- Execution Loops (6-element tracking)
- Intelligent Rituals
- KTEMA organizational memory

### API Integration Required
**Yes** â€” New event types, agent endpoints, ritual scheduler

### Database Changes Required
**Yes** â€” 8 new tables, 2 extended tables

---

## Service Type

**Recommendation:** **Hybrid Module + Agent Service**

### Rationale

1. **Module Layer:** Decision Cards, Loops, Rituals are user-facing features â†’ belong in frontend modules
2. **Agent Layer:** 6 execution agents need background processing â†’ require agent-service
3. **Connection Layer:** All events and cascades â†’ extend existing Event Bus

This is NOT a simple utility service â€” it's a **cross-cutting architectural layer** that integrates with:
- Strategy module (Decisions link to Initiatives)
- Journey module (Actions link to Goals/Habits)
- Connection Layer (Events, Suggestions)
- Notification system (Agent alerts)

---

## Suggested Architecture

### High-Level Structure

```
ExÃ­mIA APP (Monorepo)
â”‚
â”œâ”€â”€ app/                              # Frontend (Next.js)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â””â”€â”€ (dashboard)/
â”‚   â”‚   â”‚       â”œâ”€â”€ decisions/       # ğŸ†• Decision Cards pages
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ page.tsx     # List decisions
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ new/page.tsx # Create decision
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [id]/page.tsx # View/Edit decision
â”‚   â”‚   â”‚       â”œâ”€â”€ loops/           # ğŸ†• Execution Loops
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ page.tsx     # Loop dashboard
â”‚   â”‚   â”‚       â””â”€â”€ rituals/         # ğŸ†• Rituals (Phase 2)
â”‚   â”‚   â”‚           â”œâ”€â”€ page.tsx     # Calendar view
â”‚   â”‚   â”‚           â””â”€â”€ execute/[id]/page.tsx
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ decisions/           # ğŸ†• Decision components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ decision-card-form.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ decision-card-view.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ decision-list.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ loop-status-badge.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ loops/               # ğŸ†• Loop components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ execution-loop-tracker.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ loop-element-card.tsx
â”‚   â”‚   â”‚   â””â”€â”€ rituals/             # ğŸ†• Ritual components (Phase 2)
â”‚   â”‚   â”‚       â”œâ”€â”€ ritual-scheduler.tsx
â”‚   â”‚   â”‚       â””â”€â”€ ritual-executor.tsx
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ use-decisions.ts     # ğŸ†•
â”‚   â”‚   â”‚   â”œâ”€â”€ use-loops.ts         # ğŸ†•
â”‚   â”‚   â”‚   â””â”€â”€ use-rituals.ts       # ğŸ†•
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚       â””â”€â”€ camada4.ts           # ğŸ†• Camada 4 type definitions
â”‚   â”‚
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ agent-service/                    # Backend (Python FastAPI)
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”‚   â””â”€â”€ camada4/             # ğŸ†• Camada 4 agents
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â”œâ”€â”€ decision_guardian.py
â”‚   â”‚   â”‚       â”œâ”€â”€ execution_loop_agent.py
â”‚   â”‚   â”‚       â”œâ”€â”€ behavior_translator.py
â”‚   â”‚   â”‚       â”œâ”€â”€ drift_detector.py
â”‚   â”‚   â”‚       â”œâ”€â”€ learning_extractor.py
â”‚   â”‚   â”‚       â””â”€â”€ ktema_agent.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ camada4_service.py   # ğŸ†• Orchestration service
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ api/v1/
â”‚   â”‚       â””â”€â”€ camada4.py           # ğŸ†• API endpoints
â”‚   â”‚
â”‚   â””â”€â”€ requirements.txt
â”‚
â”œâ”€â”€ supabase/
â”‚   â””â”€â”€ migrations/
â”‚       â”œâ”€â”€ 001_connection_layer.sql      # Existing
â”‚       â”œâ”€â”€ 005_camada4_decisions.sql     # ğŸ†•
â”‚       â”œâ”€â”€ 006_camada4_loops.sql         # ğŸ†•
â”‚       â”œâ”€â”€ 007_camada4_rituals.sql       # ğŸ†•
â”‚       â””â”€â”€ 008_camada4_ktema.sql         # ğŸ†•
â”‚
â””â”€â”€ docs/
    â””â”€â”€ architecture/
        â”œâ”€â”€ project-analysis-camada4.md   # This analysis
        â””â”€â”€ recommended-approach-camada4.md  # This document
```

---

## Implementation Steps

### Phase 0: Foundation (REQUIRED FIRST)

Before implementing Camada 4, the following must be in place:

| Dependency | Status | Action |
|------------|--------|--------|
| Connection Layer (Event Bus) | âŒ 0% | **IMPLEMENT FIRST** |
| Entity Links | âŒ 0% | **IMPLEMENT FIRST** |
| Suggestion Engine | âŒ 0% | **IMPLEMENT FIRST** |
| Strategy Module (basic) | âŒ 0% | Minimal: Initiatives table |
| Journey Module (basic) | âŒ 0% | Minimal: Goals + Habits |

**Timeline:** 4-6 weeks

---

### Phase 1: MVP â€” Decision Cards + Guardian Agent (8 weeks)

#### Week 1-2: Database Schema

```sql
-- Migration: 005_camada4_decisions.sql

-- Decision status enum
CREATE TYPE decision_status AS ENUM ('draft', 'active', 'closed', 'abandoned');
CREATE TYPE loop_status AS ENUM ('incomplete', 'partial', 'complete');

-- Decision Cards table
CREATE TABLE decision_cards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users NOT NULL,

  -- Basic
  title TEXT NOT NULL,
  description TEXT,
  status decision_status DEFAULT 'draft',

  -- 5 Mandatory Questions (NCE)
  pain_point TEXT NOT NULL,
  expected_behavior TEXT NOT NULL,
  owner_id UUID REFERENCES auth.users,
  success_criteria TEXT NOT NULL,
  failure_consequence TEXT NOT NULL,

  -- Links
  linked_goal_id UUID,
  linked_initiative_id UUID,

  -- Lifecycle
  created_at TIMESTAMPTZ DEFAULT NOW(),
  activated_at TIMESTAMPTZ,
  deadline TIMESTAMPTZ,
  closed_at TIMESTAMPTZ,
  last_activity_at TIMESTAMPTZ DEFAULT NOW(),

  -- Config
  abandonment_days INTEGER DEFAULT 7,
  loop_status loop_status DEFAULT 'incomplete'
);

-- RLS Policies
ALTER TABLE decision_cards ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can CRUD own decisions"
  ON decision_cards FOR ALL
  USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_decisions_user ON decision_cards(user_id);
CREATE INDEX idx_decisions_status ON decision_cards(status);
CREATE INDEX idx_decisions_activity ON decision_cards(last_activity_at);
```

#### Week 2-3: Frontend - Decision Card Form

```typescript
// app/src/components/decisions/decision-card-form.tsx

'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button, Input, Textarea, Card } from '@/components/ui';
import { useDecisions } from '@/hooks/use-decisions';

const decisionSchema = z.object({
  title: z.string().min(1, 'TÃ­tulo obrigatÃ³rio'),
  pain_point: z.string().min(10, 'Descreva a dor real'),
  expected_behavior: z.string().min(10, 'Descreva o comportamento'),
  owner_id: z.string().uuid().optional(),
  success_criteria: z.string().min(10, 'Defina critÃ©rios de sucesso'),
  failure_consequence: z.string().min(10, 'Defina consequÃªncias'),
  deadline: z.string().optional(),
});

type DecisionFormData = z.infer<typeof decisionSchema>;

export function DecisionCardForm() {
  const { createDecision, isCreating } = useDecisions();
  const form = useForm<DecisionFormData>({
    resolver: zodResolver(decisionSchema),
  });

  const onSubmit = async (data: DecisionFormData) => {
    await createDecision(data);
  };

  return (
    <Card className="p-6">
      <h2 className="text-xl font-semibold mb-6">Nova DecisÃ£o</h2>

      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* Title */}
        <div>
          <label className="block text-sm font-medium mb-1">
            TÃ­tulo da DecisÃ£o *
          </label>
          <Input {...form.register('title')} placeholder="Ex: LanÃ§ar MVP atÃ© 30/03" />
          {form.formState.errors.title && (
            <p className="text-red-500 text-sm mt-1">
              {form.formState.errors.title.message}
            </p>
          )}
        </div>

        <div className="border-t pt-6">
          <h3 className="text-lg font-medium mb-4">5 Perguntas ObrigatÃ³rias</h3>

          {/* Question 1 */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">
              1. Qual dor real essa decisÃ£o resolve? *
            </label>
            <Textarea
              {...form.register('pain_point')}
              placeholder="Descreva o problema concreto..."
              rows={3}
            />
          </div>

          {/* Question 2 */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">
              2. Qual comportamento precisa mudar? *
            </label>
            <Textarea
              {...form.register('expected_behavior')}
              placeholder="Descreva algo OBSERVÃVEL..."
              rows={3}
            />
            <p className="text-sm text-gray-500 mt-1">
              ğŸ’¡ Dica: Se nÃ£o pode ser observado, nÃ£o Ã© comportamento
            </p>
          </div>

          {/* Question 3 */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">
              3. Quem sustenta no tempo? *
            </label>
            {/* UserSelect component */}
          </div>

          {/* Question 4 */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">
              4. Como sabemos se funcionou? *
            </label>
            <Textarea
              {...form.register('success_criteria')}
              placeholder="Defina critÃ©rios mensurÃ¡veis..."
              rows={3}
            />
          </div>

          {/* Question 5 */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">
              5. O que acontece se NÃƒO acontecer? *
            </label>
            <Textarea
              {...form.register('failure_consequence')}
              placeholder="Descreva as consequÃªncias..."
              rows={3}
            />
          </div>
        </div>

        <div className="flex justify-end gap-3">
          <Button variant="ghost">Cancelar</Button>
          <Button variant="secondary" type="button">
            Salvar Rascunho
          </Button>
          <Button type="submit" disabled={isCreating}>
            {isCreating ? 'Criando...' : 'Ativar DecisÃ£o'}
          </Button>
        </div>
      </form>
    </Card>
  );
}
```

#### Week 3-4: Decision Guardian Agent

```python
# agent-service/app/agents/camada4/decision_guardian.py

from datetime import datetime, timedelta
from typing import List, Optional
from dataclasses import dataclass
from supabase import Client

@dataclass
class AbandonedDecision:
    id: str
    title: str
    owner_id: str
    days_inactive: int
    last_activity_at: datetime

class DecisionGuardianAgent:
    """
    Agente GuardiÃ£o da DecisÃ£o

    FunÃ§Ã£o: Vigiar decisÃµes abertas, detectar abandono, disparar tensÃ£o saudÃ¡vel.
    Pergunta-chave: "Essa decisÃ£o ainda estÃ¡ viva?"
    """

    def __init__(self, supabase: Client):
        self.supabase = supabase
        self.default_abandonment_days = 7

    async def check_abandoned_decisions(self) -> List[AbandonedDecision]:
        """
        Verifica decisÃµes sem atividade por mais de X dias.
        Executado diariamente via cron.
        """
        threshold = datetime.now() - timedelta(days=self.default_abandonment_days)

        result = self.supabase.table('decision_cards') \
            .select('id, title, owner_id, last_activity_at, abandonment_days') \
            .eq('status', 'active') \
            .lt('last_activity_at', threshold.isoformat()) \
            .execute()

        abandoned = []
        for decision in result.data:
            days_inactive = (datetime.now() - datetime.fromisoformat(
                decision['last_activity_at']
            )).days

            abandoned.append(AbandonedDecision(
                id=decision['id'],
                title=decision['title'],
                owner_id=decision['owner_id'],
                days_inactive=days_inactive,
                last_activity_at=decision['last_activity_at']
            ))

        return abandoned

    async def process_abandoned(self, decisions: List[AbandonedDecision]):
        """
        Processa decisÃµes abandonadas:
        1. Emite evento 'decision.abandoned'
        2. Cria notificaÃ§Ã£o de alta prioridade
        3. Atualiza status se muito tempo inativo
        """
        for decision in decisions:
            # Emit event
            await self._emit_event('decision.abandoned', {
                'decision_id': decision.id,
                'title': decision.title,
                'owner_id': decision.owner_id,
                'days_inactive': decision.days_inactive
            })

            # Create notification
            await self._create_notification(
                user_id=decision.owner_id,
                type='alert',
                priority='high',
                title=f"DecisÃ£o abandonada: {decision.title}",
                body=f"Esta decisÃ£o nÃ£o tem atividade hÃ¡ {decision.days_inactive} dias. "
                     f"Ela ainda estÃ¡ viva?",
                action_url=f"/decisions/{decision.id}"
            )

            # If very inactive (>14 days), mark as abandoned
            if decision.days_inactive > 14:
                await self._mark_as_abandoned(decision.id)

    async def ask_decision_alive(self, decision_id: str) -> str:
        """
        Pergunta-chave do agente: "Essa decisÃ£o ainda estÃ¡ viva?"

        Returns prompt for user interaction.
        """
        decision = await self._get_decision(decision_id)

        return f"""
        ğŸ§  GuardiÃ£o da DecisÃ£o pergunta:

        DecisÃ£o: "{decision['title']}"
        Criada em: {decision['created_at']}
        Ãšltima atividade: {decision['last_activity_at']}

        **Essa decisÃ£o ainda estÃ¡ viva?**

        OpÃ§Ãµes:
        1. âœ… Sim, estÃ¡ ativa - [Registrar progresso]
        2. ğŸ”„ Precisa de ajustes - [Editar decisÃ£o]
        3. âŒ NÃ£o Ã© mais relevante - [Arquivar]
        4. â° Adiar verificaÃ§Ã£o - [Snooze 7 dias]
        """

    async def _emit_event(self, event_type: str, data: dict):
        """Emit event to Event Bus"""
        self.supabase.table('events').insert({
            'type': event_type,
            'source_module': 'camada4',
            'entity_type': 'decision',
            'entity_id': data.get('decision_id'),
            'data': data,
            'status': 'pending'
        }).execute()

    async def _create_notification(self, **kwargs):
        """Create notification"""
        self.supabase.table('notifications').insert(kwargs).execute()

    async def _mark_as_abandoned(self, decision_id: str):
        """Update decision status to abandoned"""
        self.supabase.table('decision_cards') \
            .update({'status': 'abandoned'}) \
            .eq('id', decision_id) \
            .execute()

    async def _get_decision(self, decision_id: str):
        """Get decision by ID"""
        result = self.supabase.table('decision_cards') \
            .select('*') \
            .eq('id', decision_id) \
            .single() \
            .execute()
        return result.data
```

#### Week 5-6: Execution Loop Tracking

```typescript
// app/src/components/loops/execution-loop-tracker.tsx

'use client';

import { useMemo } from 'react';
import { Card } from '@/components/ui';
import { Check, Circle, AlertCircle, Clock } from 'lucide-react';
import type { ExecutionLoop, LoopElement } from '@/types/camada4';

const LOOP_ELEMENTS: LoopElement[] = [
  { id: 'decision', label: 'DecisÃ£o', icon: 'ğŸ“‹' },
  { id: 'action', label: 'AÃ§Ã£o', icon: 'âœ…' },
  { id: 'behavior', label: 'Comportamento', icon: 'ğŸ¯' },
  { id: 'indicator', label: 'Indicador', icon: 'ğŸ“Š' },
  { id: 'ritual', label: 'Ritual', icon: 'ğŸ””' },
  { id: 'learning', label: 'Aprendizado', icon: 'ğŸ“š' },
];

interface Props {
  loop: ExecutionLoop;
  onElementClick?: (element: LoopElement) => void;
}

export function ExecutionLoopTracker({ loop, onElementClick }: Props) {
  const completedCount = loop.completed_elements.length;
  const progress = Math.round((completedCount / 6) * 100);

  const getElementStatus = (elementId: string) => {
    if (loop.completed_elements.includes(elementId)) return 'completed';
    if (loop.broken_at === elementId) return 'broken';
    if (loop.status === elementId) return 'current';
    return 'pending';
  };

  return (
    <Card className="p-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold">
          ğŸ” Loop de ExecuÃ§Ã£o
        </h3>
        <span className="text-sm text-gray-500">
          {progress}% completo
        </span>
      </div>

      {/* Visual Loop */}
      <div className="flex items-center justify-between mb-6">
        {LOOP_ELEMENTS.map((element, index) => (
          <div key={element.id} className="flex items-center">
            <button
              onClick={() => onElementClick?.(element)}
              className={`
                w-16 h-16 rounded-lg flex flex-col items-center justify-center
                transition-all cursor-pointer
                ${getStatusStyles(getElementStatus(element.id))}
              `}
            >
              <span className="text-2xl">{element.icon}</span>
              <span className="text-xs mt-1">{element.label}</span>
            </button>

            {index < LOOP_ELEMENTS.length - 1 && (
              <div className={`
                w-8 h-0.5 mx-1
                ${loop.completed_elements.includes(element.id)
                  ? 'bg-green-500'
                  : 'bg-gray-200 dark:bg-gray-700'}
              `} />
            )}
          </div>
        ))}
      </div>

      {/* Status */}
      <div className="text-center">
        <StatusBadge status={loop.status} brokenAt={loop.broken_at} />
      </div>
    </Card>
  );
}

function getStatusStyles(status: string) {
  switch (status) {
    case 'completed':
      return 'bg-green-100 dark:bg-green-900/20 border-2 border-green-500 text-green-700';
    case 'current':
      return 'bg-amber-100 dark:bg-amber-900/20 border-2 border-amber-500 text-amber-700 animate-pulse';
    case 'broken':
      return 'bg-red-100 dark:bg-red-900/20 border-2 border-red-500 text-red-700';
    default:
      return 'bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 text-gray-400';
  }
}

function StatusBadge({ status, brokenAt }: { status: string; brokenAt?: string }) {
  if (brokenAt) {
    return (
      <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-red-100 text-red-700 text-sm">
        <AlertCircle className="w-4 h-4" />
        Loop quebrado em: {brokenAt}
      </span>
    );
  }

  if (status === 'complete') {
    return (
      <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-green-100 text-green-700 text-sm">
        <Check className="w-4 h-4" />
        Loop completo!
      </span>
    );
  }

  return (
    <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full bg-amber-100 text-amber-700 text-sm">
      <Clock className="w-4 h-4" />
      Em progresso: {status}
    </span>
  );
}
```

#### Week 7-8: Integration & Testing

- [ ] Connect Decision Cards to Strategy Initiatives
- [ ] Connect Actions to Journey Goals/Habits
- [ ] Event emission for all decision lifecycle events
- [ ] Guardian Agent cron job setup
- [ ] Unit tests for agent logic
- [ ] E2E tests for decision flow
- [ ] Documentation update

---

### Phase 2: Loops + Rituals (6 weeks)

| Week | Deliverable |
|------|-------------|
| 9-10 | Execution Loop service (backend) |
| 11-12 | Ritual scheduler + calendar |
| 13-14 | Ritual executor UI |

### Phase 3: Additional Agents + KTEMA (6 weeks)

| Week | Deliverable |
|------|-------------|
| 15-16 | Drift Detector + Behavior Translator |
| 17-18 | Learning Extractor agent |
| 19-20 | KTEMA Memory system |

---

## Agent Assignment

| Role | Agent | Responsibilities |
|------|-------|------------------|
| **Primary** | @dev | Decision Card UI, Loop Tracker, API endpoints, Database migrations |
| **Architecture** | @architect | Agent framework design, Event integration, Data model |
| **UX** | @ux-design-expert | Decision Card form UX, Loop visualization, Ritual flow |
| **Data** | @data-engineer | Schema optimization, RLS policies, Query performance |
| **QA** | @qa | Agent behavior testing, Integration tests, E2E flows |

---

## Dependencies

### NPM Packages (Frontend)

```json
{
  "dependencies": {
    "react-hook-form": "^7.x",
    "zod": "^3.x",
    "@hookform/resolvers": "^3.x",
    "date-fns": "^3.x"
  }
}
```

### Python Packages (Agent Service)

```txt
# requirements.txt additions
apscheduler>=3.10.0  # Cron scheduling
supabase>=2.0.0      # Database client
pydantic>=2.0.0      # Data validation
```

### Infrastructure

- Supabase (existing)
- Agent service deployment (Railway recommended)
- Cron job service (Railway cron or Supabase Edge Functions)

---

## Risk Mitigations

| Risk | Mitigation |
|------|------------|
| Scope creep | Strict Phase 1 boundary: Only Decision Cards + Guardian |
| Agent complexity | Start with single agent, add others incrementally |
| User adoption | Excellent UX, minimal mandatory fields, helpful guidance |
| Connection Layer dependency | Build Connection Layer FIRST before Camada 4 |

---

## Success Criteria

### Phase 1 MVP

- [ ] Users can create Decision Cards with 5 mandatory questions
- [ ] Decision Guardian agent runs daily, detects abandonment
- [ ] Loop status tracked (at least 3 elements)
- [ ] Events emitted for all decision lifecycle states
- [ ] 70%+ test coverage on agent logic

### Validation Metrics

| Metric | Target | Method |
|--------|--------|--------|
| Decisions created | >50 in pilot | Database count |
| Abandonment detected | 100% accuracy | Agent logs |
| User completion rate | >60% (draft â†’ active) | Funnel analysis |
| Time to first action | <48h | Timestamp delta |

---

## Next Steps

After this analysis is approved:

1. **Review with stakeholders** â€” Validate scope and timeline
2. **Implement Connection Layer** â€” Required foundation (4-6 weeks)
3. **Design Decision Card UX** â€” Wireframes and prototypes
4. **Create database migrations** â€” Schema for Phase 1
5. **Scaffold agent service** â€” Python FastAPI structure
6. **Begin Phase 1 implementation** â€” Decision Cards + Guardian

---

**Would you like me to proceed with:**

1. `*create-full-stack-architecture` â€” Complete architecture document
2. Design Decision Card UX mockups
3. Create database migration files
4. Scaffold agent service structure

Select an option or provide direction.

---

**Generated by:** Aria (Architect Agent)
**Date:** 2026-01-28
**Status:** Ready for Approval
